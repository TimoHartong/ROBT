#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include "io.h"
#include "fb.h"                         // Debug and wait routine
//#include "bt.h"
#include "PI3MEM.h"
#include "ros_utils.h"
#include "pi_pl11.h"
//#include "types.h"
#include "gplfix.h"
#include "gpl/include/net/bluetooth/bluetooth.h"
#include "gpl/include/net/bluetooth/hci.h"



// Struct used to return varible data from function
struct rData
{
    uint32_t  nLength;   // Size of the struct
    uint8_t   *pData;    // A byte array of return data
    uint32_t  nStatus;   // The status of the request
};

struct read_local_version
{
  uint8_t   hci_version;
  uint16_t  hci_rev;
  uint8_t   lmp_ver;
  uint16_t  manufacterer;
  uint16_t  lmp_subver;
};


struct bcm_subver_table {
	uint16_t subver;
	const char *name;
};

// Taken from linux source
static const struct bcm_subver_table bcm_uart_subver_table[] = {
	{ 0x1111, "BCM4362A2"	},	/* 000.017.017 */
	{ 0x4103, "BCM4330B1"	},	/* 002.001.003 */
	{ 0x410d, "BCM4334B0"	},	/* 002.001.013 */
	{ 0x410e, "BCM43341B0"	},	/* 002.001.014 */
	{ 0x4204, "BCM2076B1"	},	/* 002.002.004 */
	{ 0x4406, "BCM4324B3"	},	/* 002.004.006 */
	{ 0x4606, "BCM4324B5"	},	/* 002.006.006 */
	{ 0x6109, "BCM4335C0"	},	/* 003.001.009 */
	{ 0x610c, "BCM4354"	},	/* 003.001.012 */
	{ 0x2122, "BCM4343A0"	},	/* 001.001.034 */
	{ 0x2209, "BCM43430A1"  },	/* 001.002.009 */
	{ 0x6119, "BCM4345C0"	},	/* 003.001.025 */
	{ 0x6606, "BCM4345C5"	},	/* 003.006.006 */
	{ 0x230f, "BCM4356A2"	},	/* 001.003.015 */
	{ 0x220e, "BCM20702A1"  },	/* 001.002.014 */
	{ 0x420d, "BCM4349B1"	},	/* 002.002.013 */
	{ 0x420e, "BCM4349B1"	},	/* 002.002.014 */
	{ 0x4217, "BCM4329B1"   },	/* 002.002.023 */
	{ 0x6106, "BCM4359C0"	},	/* 003.001.006 */
	{ 0x4106, "BCM4335A0"	},	/* 002.001.006 */
	{ 0x410c, "BCM43430B0"	},	/* 002.001.012 */
	{ 0x2119, "BCM4373A0"	},	/* 001.001.025 */
	{ 0x2310, "BCM4343A2"	},	/* 001.003.016 */
	{ 0x0000, 0 }
};



// UART0
static struct PL11STR* pUART = NULL;

static unsigned char lo(unsigned int val)
{
    return (unsigned char)(val & 0xff);
}

static unsigned char hi(unsigned int val)
{
    return (unsigned char)((val & 0xff00) >> 8);
}

unsigned int bt_isReadByteReady(void)
{
    //printf("is Read byte ready (boolean) : %08X \n", pUART->UART0_FR);
    return (pUART->UART0_FR & RXFE) == 0 ;
}

unsigned char bt_readByte(void)
{
  //  uint32_t ret = pUART->UART0_DR ;
  //  printf("bt_ReadByte %08X \n", ret);
  //  unsigned char ch = lo(pUART->UART0_DR);
  //  return ch;
    return lo(pUART->UART0_DR);
}

// Detect if the FIFO is empty, This is used to detect if a complete commnand has been send
// Return 1 when UART is busy transmitting
static uint32_t bt_TxBusy(void)
{
    return ( pUART->UART0_FR & BUSY ) == BUSY ;
}

unsigned char bt_waitReadByte(void)
{
    while (!bt_isReadByteReady())
        msleep(1);
    //printf("After read byte ready \n");
    return bt_readByte();
}

void bt_writeByte(char byte)
{
   //printf("w Byte %02X \n",byte);
    while ( pUART->UART0_FR & TXFF )
        msleep(1);

    pUART->UART0_DR = byte;
}

static void bt_flushrx(void)
{
    while (bt_isReadByteReady())
        bt_readByte();
}

// Configures the GPIO
// FIXME make more configurable
static void bt_ConfigureGPIO(uint32_t nReset)
{
    gpio_useAsOut(nReset);       // BT_ON for reset of the chip
    gpio_useAsOut(14);
    gpio_useAsOut(15);
    gpio_useAsAlt3(0x1e);   // CTS
    gpio_useAsAlt3(0x1f);   // RTS
    gpio_useAsAlt3(0x20);   // TxD
    gpio_useAsAlt3(0x21);   // RxD
    // The GPIO are set standard set as no pull
    gpio_pull(0x1e,1);
    gpio_pull(0x21,1);
}

// Reset the BT chip
// On entry :
// nOffTime : Duration of the low for the BT_ON in msec
// nAfterRs : After reset time in msec
static void bt_ResetChip(uint32_t pin, uint32_t nOffTime, uint32_t nAfterRst)
{
    gpio_set(pin);
    msleep(1000);
    gpio_clear(pin);
    msleep(nOffTime);
    gpio_set(pin);
    msleep(nAfterRst);
}

void bt_init(void)
{
    uint32_t uart_clk = 0;
    uint32_t divider = 0;
    uint32_t scrap = 0;
    uint32_t fraction = 0;
    uint32_t baud = 115200;
    // First init the point to the PL11 UART. OS_Memory always makes a size of 1 Mbyte
    if ( pUART == NULL )
        pUART = (struct PL11STR*) IOToUser(UART0, sizeof(struct PL11STR) * 4 );

    // 1. Calculate baudrate
    uart_clk  = UARTClkFreq();
    divider   = uart_clk / ( 16 * baud );
    scrap     = ((( uart_clk % ( 16 * baud )) * 8 ) / baud );
    fraction  = (scrap >> 1) + (scrap & 1);

    //printf("uart clk : %d , divider : %X, fraction : %d \n", uart_clk, divider, fraction );

    // 2. Route UART to correct pins.
    bt_ConfigureGPIO(42);
    printf("BT chip being resetted...\n");
    bt_ResetChip(42,50,1000);
    printf("BT chip resetted...\n");

    printf("Flush UART 0 \n");
    bt_flushrx();

     pUART->UART0_CR    = 0                        ; // Stop the UART
     msleep(100);
     pUART->UART0_ICR   = 0x7ff                    ; // Clear interrupts
     pUART->UART0_IBRD  = divider                  ; // Integer baud rate generator
     pUART->UART0_FBRD  = fraction                ; // Fractional baudrate
     //pUART->UART0_IFLS  = FIFO_14 << 3             ; // FIFO level
     pUART->UART0_LCRH  = FEN | BITS_8             ; // 8 Data bits enable FIFO
     pUART->UART0_CR    = CTSEN | RTSEN | RTS | RXE | TXE  ;
     pUART->UART0_CR    = CTSEN | RTSEN | RTS | RXE | TXE | UARTEN ;

     pUART->UART0_IMSC  = 0     ;

     // The DTR line has to be low for the BT chip for some time
     msleep(50);
     bt_flushrx();
}

// HOST SETUP

enum {
    OGF_HOST_CONTROL          = 0x03,
    OGF_LE_CONTROL            = 0x08,
    OGF_VENDOR                = 0x3f,

    COMMAND_SET_BDADDR        = 0x01,
    COMMAND_RESET_CHIP        = 0x03,
    COMMAND_SET_BAUD          = 0x18,
    COMMAND_LOAD_FIRMWARE     = 0x2e,

  //  HCI_COMMAND_PKT           = 0x01,
    HCI_ACL_PKT               = 0x02,
 //   HCI_EVENT_PKT             = 0x04,
    COMMAND_COMPLETE_CODE     = 0x0e,
    CONNECT_COMPLETE_CODE     = 0x0f,

    LL_SCAN_ACTIVE            = 0x01,
    LL_ADV_NONCONN_IND        = 0x03
};

/* Only send the command this function is unaware of the return */
static uint32_t hciCmdSend(unsigned char *opcodebytes, volatile unsigned char *data, unsigned char length)
{
}

struct rData hciCommandBytes(unsigned char *opcodebytes, volatile unsigned char *data, unsigned char length)
{
    //printf("HCI Command bytes \n");
    unsigned char c=0;
    struct rData ret = {0,NULL,0xffff};

    bt_writeByte(HCI_COMMAND_PKT);
    bt_writeByte(opcodebytes[0]);
    bt_writeByte(opcodebytes[1]);
    bt_writeByte(length);

    while (c++<length)
        bt_writeByte(*data++);

    // Wait untill transmitting is complete
    while( bt_TxBusy())
        msleep(1);

error:
    if (bt_waitReadByte() != HCI_EVENT_PKT)
    {
        if ( pUART->RSRECR )
        {
            pUART->RSRECR = 0;
            goto error;
        }
        ret.nStatus = 1;
        return ret;
    }

    unsigned char code = bt_waitReadByte();
    if (code == CONNECT_COMPLETE_CODE)
    {
       if (bt_waitReadByte() != 4)
       {
           ret.nStatus = 2;
           return ret;
       }

       unsigned char err = bt_waitReadByte();
       if (err != 0)
       {
	  uart_writeText("Saw HCI COMMAND STATUS error ");
	  uart_hex(err);
	  uart_writeText("\n");
	  ret.nStatus = 12;
          return ret;
       }

       if (bt_waitReadByte() == 0)
       {
           ret.nStatus = 3;
           return ret;
       }

       if (bt_waitReadByte() != opcodebytes[0])
       {
           ret.nStatus = 4;
           return ret;
       }

       if (bt_waitReadByte() != opcodebytes[1])
       {
           ret.nStatus = 5;
           return ret;
       }
    }
    else if (code == COMMAND_COMPLETE_CODE)
    {
       if (bt_waitReadByte() != 4)
       {
           ret.nStatus = 6;
           return ret;
       }

       if (bt_waitReadByte() == 0)
       {
           ret.nStatus = 7;
           return ret;
       }

       //if (bt_waitReadByte() != opcodebytes[0]) return 8;
       if (bt_waitReadByte() != opcodebytes[0])
       {
           ret.nStatus = 8;
           return ret;
       }

       //if (bt_waitReadByte() != opcodebytes[1]) return 9;
       if (bt_waitReadByte() != opcodebytes[1])
       {
           ret.nStatus = 9;
           return ret;
       }

       if (bt_waitReadByte() != 0)
       {
           ret.nStatus = 12;
           return ret;
       }
    }
    else
    {
         ret.nStatus = 11;
         return ret;
     }
    ret.nStatus = 0;
    return ret;
}

struct rData hciCommand(unsigned short ogf, unsigned short ocf, volatile unsigned char *data, unsigned char length)
{
    unsigned short opcode = ogf << 10 | ocf;
    unsigned char opcodebytes[2] = { lo(opcode), hi(opcode) };

    return hciCommandBytes(opcodebytes, data, length);
}

void bt_reset(void)
{
    struct rData ret = {0, NULL, 0};
    //volatile unsigned char empty[] = {};
    unsigned char empty[100];
    ret = hciCommand(OGF_HOST_CONTROL, COMMAND_RESET_CHIP, empty, 0);
    if (ret.nStatus )
    {
      printf("bt_reset() failed with error code %d \n", ret.nStatus );
      return;
    }

    printf("bt_reset succes !!!\n");
}

// Read in firmware based on linuxquestions.org
// On entry:
// filename : name of the file
// On exit
// Structure with filelenght and pointer to memory block containing fw
// must be cleanup with free
struct rData LoadFirmware(char* filename)
{
    FILE *file;
    struct rData ret = {0, NULL,0 } ;

    // Open file rb as binary
    file = fopen( filename ,"rb");
    if (!file)
    {
        printf("Error in opening file \n");
        ret.pData = NULL ;
        ret.nLength = 0;
        ret.nStatus = 1;
        return ret ;
    }

    // Get file lenght
    fseek(file ,0 , SEEK_END);
    ret.nLength = ftell(file);
    // Set to start of file
    fseek(file ,0, SEEK_SET);

    // Allocate memory
    ret.pData = (uint8_t*) malloc( ret.nLength + 1);


    if ( !ret.pData )
    {
       printf("Memory allocation error \n");
       fclose(file);
       ret.pData = NULL ;
       ret.nLength = 0;
       ret.nStatus = 2;
       return ret ;
    }

    // Read file contents into buffer
    fread(ret.pData,  ret.nLength ,1, file);
    // Valid file handle ?
    fclose(file);

    return ret;
}


void bt_loadfirmware(char* filename)
{
    struct rData ret;
    int nRet;
    //volatile unsigned char empty[] = {};
    unsigned char empty[100];
    if (hciCommand(OGF_VENDOR, COMMAND_LOAD_FIRMWARE, empty, 0).nStatus )
    {
         uart_writeText("loadFirmware() failed\n");
         return;
    }

    msleep(100);
    printf("Reset chip succesfull \n");
    // Now load the firmware file
    ret = LoadFirmware(filename);
    printf("bt Load Firmware : status %d file lenght : %d \n",ret.nStatus , (int) ret.nLength );

    unsigned int c=0;
    unsigned int size = ret.nLength ;

    unsigned char opcodebytes[2];
    unsigned char length;
    unsigned char *data ; // = &(_binary_BCM4345C0_hcd_start[0]);

    data = (unsigned char*) ret.pData ;

    while (c < size)
    {
        opcodebytes[0] = *data;
        opcodebytes[1] = *(data+1);
        length =         *(data+2);
        data += 3;

        if (hciCommandBytes(opcodebytes, data, length).nStatus )
        {
	   uart_writeText("Firmware data load failed\n");
	   break;
	}

	data += length;
        c += 3 + length;
    }

    free(ret.pData);
    ret.pData = NULL;

    msleep(1000);
    printf("FW loadeded annd after delay \n");
}

void bt_setbaud(void)
{
    volatile unsigned char command[6] = { 0, 0, 0x00, 0xc2, 0x01, 0x00 }; // little endian, 115200
    if (hciCommand(OGF_VENDOR, COMMAND_SET_BAUD, command, 6).nStatus)
    {
        printf("bt_setbaud() failed\n");
        return;
    }
     //   uart_writeText("bt_setbaud() failed\n");
     printf("Set baud successfull\n");
}

void bt_setbdaddr(void)
{
    volatile unsigned char command[6] = { 0xee, 0xff, 0xc0, 0xee, 0xff, 0xc0 }; // reversed
    if (hciCommand(OGF_VENDOR, COMMAND_SET_BDADDR, command, 6).nStatus)
        uart_writeText("bt_setbdaddr() failed\n");
}



void bt_getbdaddr(unsigned char *bdaddr)
{
    bt_writeByte(HCI_COMMAND_PKT);
    bt_writeByte(0x09);
    bt_writeByte(0x10);
    bt_writeByte(0x00);

    if (bt_waitReadByte() != HCI_EVENT_PKT) return;
    if (bt_waitReadByte() != COMMAND_COMPLETE_CODE) return;
    if (bt_waitReadByte() != 0x0a) return;
    if (bt_waitReadByte() != 1) return;
    if (bt_waitReadByte() != 0x09) return;
    if (bt_waitReadByte() != 0x10) return;
    if (bt_waitReadByte() != 0x00) return;

    for (int c=0;c<6;c++)
        bdaddr[c] = bt_waitReadByte();
}

// Taken from linux source /include/net/bluetooth/hci.h
#define HCI_MAX_NAME_LENGTH   248

void btbcm_read_verbose_config(void)
{
    int ret ;
    int iMsgSize = 0;
    uint8_t scrap[HCI_MAX_NAME_LENGTH] = {0};

    // HCI_READ_LOCAL_NAME 0x0c14
    bt_writeByte(HCI_COMMAND_PKT);
    bt_writeByte(0x79);
    bt_writeByte(0xfc);
    bt_writeByte(0x00);

    while( bt_TxBusy())
        msleep(1);

    // The usuall checks
    if ( bt_waitReadByte() != HCI_EVENT_PKT) return;
    if (bt_waitReadByte() != COMMAND_COMPLETE_CODE) return;
    iMsgSize = bt_waitReadByte();
    if (bt_waitReadByte() != HCI_COMMAND_PKT) return;
    if (bt_waitReadByte() != 0x79) return;
    if (bt_waitReadByte() != 0xfc) return;
    if (bt_waitReadByte() != 0x00) return;


    printf("BCM : chip id %u \n",bt_waitReadByte()) ;

    // Now read the rest of the data to empty the the rx buffer
    for(int i = 0; i < iMsgSize - 5  ; i++)
    {
        scrap[i] = bt_waitReadByte();
        //printf("%02X \n",scrap[i] ) ;
    }
}

// Name of the proto taken from Linux(GPL) source
// drivers/bluetooth/btbcm.c
void btbcm_read_local_name(void)
{
    //uint8_t scrap[sizeof(version)];
    int iMsgSize = 0;
    uint8_t scrap[HCI_MAX_NAME_LENGTH] = {0};

    // HCI_READ_LOCAL_NAME 0x0c14
    bt_writeByte(HCI_COMMAND_PKT);
    bt_writeByte(0x14);
    bt_writeByte(0x0c);
    bt_writeByte(0x00);

    while( bt_TxBusy())
        msleep(1);

        // The usuall checks
    if (bt_waitReadByte() != HCI_EVENT_PKT) return;
    if (bt_waitReadByte() != COMMAND_COMPLETE_CODE) return;
    iMsgSize = bt_waitReadByte();
    if (bt_waitReadByte() != HCI_COMMAND_PKT) return;
    if (bt_waitReadByte() != 0x14) return;
    if (bt_waitReadByte() != 0x0c) return;
    if (bt_waitReadByte() != 0x00) return;

    printf("Local name : \n");
    for(int i = 0; i < iMsgSize - 4  ; i++)
    {
        scrap[i] = bt_waitReadByte();
        //printf("%02X", scrap[i]);
    }

    printf("\n %s \n",scrap) ;

}

// Name of the proto taken from Linux (GPL) source
// drivers/bluetooth/btbcm.c
void btbcm_read_controller_features(void)
{
    //uint8_t scrap[sizeof(version)];
    int iMsgSize = 0;
    // 0x1001
    bt_writeByte(HCI_COMMAND_PKT);
    bt_writeByte(0x6e);
    bt_writeByte(0xfc);
    bt_writeByte(0x00);

    while( bt_TxBusy())
        msleep(1);

    // The usuall checks
    if (bt_waitReadByte() != HCI_EVENT_PKT) return;
    if (bt_waitReadByte() != COMMAND_COMPLETE_CODE) return;
    iMsgSize = bt_waitReadByte();
    if (bt_waitReadByte() != HCI_COMMAND_PKT) return;
    if (bt_waitReadByte() != 0x6e) return;
    if (bt_waitReadByte() != 0xfc) return;
    if (bt_waitReadByte() != 0x00) return;

    printf("BCM : features 0x%2.2x \n",bt_waitReadByte()) ;

    // Now read the rest of the data to empty the the rx buffer

    // Put the actuall intterting things in the array
    for(int i = 0; i < iMsgSize - 5  ; i++)
        bt_waitReadByte();

    printf("btbcm_read_controlle_features complete \n");

}

void bt_get_local_version(unsigned char* data)
{
   struct read_local_version version;
   int iMsgSize = 0;
   uint8_t scrap[sizeof(version)];
   const char *hw_name = NULL;

  // 0x1001
    bt_writeByte(HCI_COMMAND_PKT);
    bt_writeByte(0x01);
    bt_writeByte(0x10);
    bt_writeByte(0x00);

    while( bt_TxBusy())
        msleep(1);


    // The usuall checks
    if (bt_waitReadByte() != HCI_EVENT_PKT) return;
    if (bt_waitReadByte() != COMMAND_COMPLETE_CODE) return;
    iMsgSize = bt_waitReadByte();
    if (bt_waitReadByte() != HCI_COMMAND_PKT) return;
    if (bt_waitReadByte() != 0x01) return;
    if (bt_waitReadByte() != 0x10) return;
    if (bt_waitReadByte() != 0x00) return;

    // Put the actuall intterting things in the array
    for(int i = 0; i < iMsgSize - 4  ; i++)
    {
      scrap[i] = bt_waitReadByte();
      //printf("local version received bytes : %02X \n", scrap[i]);
    }

    memcpy(&version, scrap, sizeof(version));
    printf("HCI Version : %X \n", version.hci_version );
    printf("HCI Revision : %X \n", version.hci_rev );            // rev
    printf("HCI LMP Version : %X \n", version.lmp_ver );
    printf("HCI Manufacterer : %X \n", version.manufacterer);
    printf("HCI LMP Subersion : %X \n", version.lmp_subver);    // Subver

    //printf("find name of FW file \n");

    //return;
    for (int i = 0;  bcm_uart_subver_table[i].name; i++)
    {
        if (version.manufacterer == bcm_uart_subver_table[i].subver)
        {
            hw_name = bcm_uart_subver_table[i].name;
	    break;
	}
    }

    printf("%s (%3.3u.%3.3u.%3.3u) build %4.4u \n",hw_name ? hw_name : "BCM",(version.manufacterer & 0xe000 ) >> 13, (version.manufacterer & 0x1f00 ) >> 8 , (version.manufacterer & 0x00ff ), version.hci_rev & 0x0fff );

}

void sendACLsubscribe(unsigned int handle)
{
    bt_writeByte(HCI_ACL_PKT);

    bt_writeByte(lo(handle));
    bt_writeByte(hi(handle));

    unsigned int length = 0x0009;
    bt_writeByte(lo(length));
    bt_writeByte(hi(length));

    unsigned int data_length = 0x0005;
    bt_writeByte(lo(data_length));
    bt_writeByte(hi(data_length));

    unsigned int channel = 0x0004;
    bt_writeByte(lo(channel));
    bt_writeByte(hi(channel));

    volatile unsigned char command[5] = { 0x12, 0x2b, 0x00, 0x01, 0x00 };

    unsigned int c=0;
    while (c++<data_length) bt_writeByte(command[c-1]);
}

void setLEeventmask(unsigned char mask)
{
    volatile unsigned char command[8] = { 0 };
    command[0] = mask;

    printf("setLEeventmask %02X\n", mask );

    if (hciCommand(OGF_LE_CONTROL, 0x01, command, 8).nStatus)
        printf("setLEeventmask failed\n");
    else
        printf("setLEeventmask succes\n");

}

void setLEscanenable(unsigned char state, unsigned char duplicates) {
    volatile unsigned char command[2];
    command[0] = state;
    command[1] = duplicates;
    if (hciCommand(OGF_LE_CONTROL, 0x0c, command, 2).nStatus)
        printf("setLEscanenable failed\n");
    else
        printf("setLEscanenable succes\n");
}

void setLEscanparameters(unsigned char type, unsigned char linterval, unsigned char hinterval, unsigned char lwindow, unsigned char hwindow, unsigned char own_address_type, unsigned char filter_policy)
{
    volatile unsigned char command[7];
    command[0] = type;
    command[1] = linterval;
    command[2] = hinterval;
    command[3] = lwindow;
    command[4] = hwindow;
    command[5] = own_address_type;
    command[6] = filter_policy;
    if (hciCommand(OGF_LE_CONTROL, 0x0b, command, 7).nStatus)
        printf("setLEscanparameters failed\n");
    else
        printf("setLEscanparameters succes\n");
}

void setLEadvertenable(unsigned char state) {
    volatile unsigned char command[1];
    command[0] = state;
    if (hciCommand(OGF_LE_CONTROL, 0x0a, command, 1).nStatus)
        uart_writeText("setLEadvertenable failed\n");
}

void setLEadvertparameters(unsigned char type, unsigned char linterval_min, unsigned char hinterval_min, unsigned char linterval_max, unsigned char hinterval_max, unsigned char own_address_type, unsigned char filter_policy) {
    volatile unsigned char command[15] = { 0 };

    command[0] = linterval_min;
    command[1] = hinterval_min;
    command[2] = linterval_max;
    command[3] = hinterval_max;
    command[4] = type;
    command[5] = own_address_type;
    command[13] = 0x07;
    command[14] = filter_policy;

    if (hciCommand(OGF_LE_CONTROL, 0x06, command, 15).nStatus)
        uart_writeText("setLEadvertparameters failed\n");
}

void setLEadvertdata(void) {
    static unsigned char command[32] = {
       0x19,
       0x02, 0x01, 0x06, // flags and length
       0x03, 0x03, 0xAA, 0xFE,
       0x10, 0x16, 0xAA, 0xFE, 0x10, 0x00, 0x03,
       0x68, 0x61, 0x72, 0x74, 0x6f, 0x6e, 0x67,
       0x2e, 0x65, 0x75, 0x00,
       0, 0, 0, 0, 0, 0
    };

    if (hciCommand(OGF_LE_CONTROL, 0x08, command, 32).nStatus)
        uart_writeText("setLEadvertdata failed\n");
}

void stopScanning(void) {
    setLEscanenable(0, 0);
}

void stopAdvertising(void) {
    setLEadvertenable(0);
}

void startActiveScanning(void) {
    float BleScanInterval = 60; // every 60ms
    float BleScanWindow = 60;
    float BleScanDivisor = 0.625;

    unsigned int p = BleScanInterval / BleScanDivisor;
    unsigned int q = BleScanWindow / BleScanDivisor;

    setLEscanparameters(LL_SCAN_ACTIVE, lo(p), hi(p), lo(q), hi(q), 0, 0);
    setLEscanenable(1, 0);
}

void startActiveAdvertising(void) {
    float advertMinFreq = 100; // every 100ms
    float advertMaxFreq = 100; // every 100ms
    float bleGranularity = 0.625;

    unsigned int min_interval = advertMinFreq / bleGranularity;
    unsigned int max_interval = advertMaxFreq / bleGranularity;

    setLEadvertparameters(LL_ADV_NONCONN_IND, lo(min_interval), hi(min_interval), lo(max_interval), hi(max_interval), 0, 0);
    setLEadvertdata();
    setLEadvertenable(1);
}

void connect(unsigned char *addr)
{
    float BleScanInterval = 60; // every 60ms
    float BleScanWindow = 60;
    float BleScanDivisor = 0.625;

    float connMinFreq = 30; // every 30ms
    float connMaxFreq = 50; // every 50ms
    float BleGranularity = 1.25;

    unsigned int p = BleScanInterval / BleScanDivisor;
    unsigned int q = BleScanWindow / BleScanDivisor;

    unsigned int min_interval = connMinFreq / BleGranularity;
    unsigned int max_interval = connMaxFreq / BleGranularity;

    volatile unsigned char command[25] = { 0 };

    command[0] = lo(p);
    command[2] = lo(q);
    command[6] = *(addr+5);
    command[7] = *(addr+4);
    command[8] = *(addr+3);
    command[9] = *(addr+2);
    command[10] = *(addr+1);
    command[11] = *addr;
    command[13] = lo(min_interval);
    command[15] = lo(max_interval);
    command[19] = 0x2a;
    command[20] = 0x00;

    if (hciCommand(OGF_LE_CONTROL, 0x0d, command, 25).nStatus)
        uart_writeText("createLEconnection failed\n");
}
